#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    PowerExpander,  sensorAnalog)
#pragma config(Sensor, dgtl1,  Brake1,         sensorDigitalOut)
#pragma config(Sensor, dgtl2,  Brake2,         sensorDigitalOut)
#pragma config(Sensor, dgtl3,  collection_encoder, sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  encoder_leftB,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  encoder_leftA,  sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  encoder_rightA, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  encoder_rightB, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           CollectionB,   tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LeftB,         tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           RightB,        tmotorVex393_MC29, PIDControl, encoderPort, I2C_4)
#pragma config(Motor,  port4,           LeftA,         tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port5,           RightA,        tmotorVex393_MC29, PIDControl, encoderPort, I2C_3)
#pragma config(Motor,  port6,           DriveRearLeft, tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port7,           DriveRearRight, tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port8,           DriveFrontLeft, tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port9,           DriveFrontRight, tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,          CollectionA,   tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MOTOR_TPR_269           240.448
#define MOTOR_TPR_393R          261.333
#define MOTOR_TPR_393S          392
#define MOTOR_TPR_393T          627.2
#define MOTOR_TPR_QUAD          360.0

#define FWL_LOOP_SPEED              25
#define FWL_MAX_POWER              120

#define FWR_LOOP_SPEED              25
#define FWR_MAX_POWER              120

typedef struct _fwL_controller {
	long            counter;
	float           ticks_per_rev;
	long            e_current;
	long            e_last;
	float           v_current;
	long            v_time;
	long            target;
	long            current;
	long            last;
	float           error;
	float           last_error;
	float           gain;
	float           drive;
	float           drive_at_zero;
	long            first_cross;
	float           drive_approx;
	long            motor_drive;
} fwL_controller;

typedef struct _fwR_controller {
	long            counter;
	float           ticks_per_rev;
	long            e_current;
	long            e_last;
	float           v_current;
	long            v_time;
	long            target;
	long            current;
	long            last;
	float           error;
	float           last_error;
	float           gain;
	float           drive;
	float           drive_at_zero;
	long            first_cross;
	float           drive_approx;
	long            motor_drive;
} fwR_controller;

static  fwL_controller   flywheelL;
static  fwR_controller   flywheelR;
/*-----------------------------------------------------------------------------*/
/** @brief      Set the flywheen motors                                        */
/** @param[in]  value motor control value                                      */
/*-----------------------------------------------------------------------------*/
void
FwLMotorSet( int motorSpeed )
{
	motor[LeftB] = motorSpeed;
	motor[LeftA] = motorSpeed;
}

void
FwRMotorSet( int motorSpeed )
{
	motor[RightB] = motorSpeed;
	motor[RightA] = motorSpeed;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Get the flywheen motor encoder count                           */
/*-----------------------------------------------------------------------------*/
long
FwLMotorEncoderGet()
{
	return( SensorValue[encoder_leftA] * 49/3 * -1);
}

long
FwRMotorEncoderGet()
{
	return( SensorValue[encoder_rightA] * 49/3 );
}

/*-----------------------------------------------------------------------------*/
/** @brief      Set the controller position                                    */
/** @param[in]  fw pointer to flywheel controller structure                    */
/** @param[in]  desired velocity                                               */
/** @param[in]  predicted_drive estimated open loop motor drive                */
/*-----------------------------------------------------------------------------*/
void
FwLVelocitySet( fwL_controller *fwL, int velocity, float predicted_drive )
{
	fwL->target        = velocity;
	fwL->error         = fwL->target - fwL->current;
	fwL->last_error    = fwL->error;
	fwL->drive_approx  = predicted_drive;
	fwL->first_cross   = 1;
	fwL->drive_at_zero = 0;
}

void
FwRVelocitySet( fwR_controller *fwR, int velocity, float predicted_drive )
{
	fwR->target        = velocity;
	fwR->error         = fwR->target - fwR->current;
	fwR->last_error    = fwR->error;
	fwR->drive_approx  = predicted_drive;
	fwR->first_cross   = 1;
	fwR->drive_at_zero = 0;
}
/*-----------------------------------------------------------------------------*/
/** @brief      Calculate the current flywheel motor velocity                  */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwLCalculateSpeed( fwL_controller *fwL )
{
	int     delta_ms;
	int     delta_enc;
	fwL->e_current = FwLMotorEncoderGet();
	delta_ms   = nSysTime - fwL->v_time;
	fwL->v_time = nSysTime;
	delta_enc = (fwL->e_current - fwL->e_last);
	fwL->e_last = fwL->e_current;
	fwL->v_current = (1000.0 / delta_ms) * delta_enc * 60.0 / fwL->ticks_per_rev;
}

void
FwRCalculateSpeed( fwR_controller *fwR )
{
	int     delta_ms;
	int     delta_enc;
	fwR->e_current = FwRMotorEncoderGet();
	delta_ms   = nSysTime - fwR->v_time;
	fwR->v_time = nSysTime;
	delta_enc = (fwR->e_current - fwR->e_last);
	fwR->e_last = fwR->e_current;
	fwR->v_current = (1000.0 / delta_ms) * delta_enc * 60.0 / fwR->ticks_per_rev;
}
/*-----------------------------------------------------------------------------*/
/** @brief      Update the velocity tbh controller variables                   */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwLControlUpdateVelocityTbh( fwL_controller *fwL )
{
	fwL->error = fwL->target - fwL->current;
	fwL->drive =  fwL->drive + (fwL->error * fwL->gain);
	if( fwL->drive > 1 )
		fwL->drive = 1;
	if( fwL->drive < 0 )
		fwL->drive = 0;
	if( sgn(fwL->error) != sgn(fwL->last_error) ) {
		if( fwL->first_cross ) {
			fwL->drive = fwL->drive_approx;
			fwL->first_cross = 0;
		}
		else
			fwL->drive = 0.5 * ( fwL->drive + fwL->drive_at_zero );
		fwL->drive_at_zero = fwL->drive;
	}
	fwL->last_error = fwL->error;
}

void
FwRControlUpdateVelocityTbh( fwR_controller *fwR )
{
	fwR->error = fwR->target - fwR->current;
	fwR->drive =  fwR->drive + (fwR->error * fwR->gain);
	if( fwR->drive > 1 )
		fwR->drive = 1;
	if( fwR->drive < 0 )
		fwR->drive = 0;
	if( sgn(fwR->error) != sgn(fwR->last_error) ) {
		if( fwR->first_cross ) {
			fwR->drive = fwR->drive_approx;
			fwR->first_cross = 0;
		}
		else
			fwR->drive = 0.5 * ( fwR->drive + fwR->drive_at_zero );
		fwR->drive_at_zero = fwR->drive;
	}
	fwR->last_error = fwR->error;
}

/*-----------------------------------------------------------------------------*/
/** @brief     Task to control the velocity of the flywheel                    */
/*-----------------------------------------------------------------------------*/
task
FwLControlTask()
{
	fwL_controller *fwL = &flywheelL;
	fwL->gain = 0.00015;
	fwL->ticks_per_rev = MOTOR_TPR_393S;
	while(1)
	{
		fwL->counter++;
		FwLCalculateSpeed( fwL );
		fwL->current = fwL->v_current;
		FwLControlUpdateVelocityTbh( fwL ) ;
		fwL->motor_drive  = (fwL->drive * FWL_MAX_POWER) + 0.5;
		if( fwL->motor_drive >  127 ) fwL->motor_drive =  127;
		if( fwL->motor_drive < -127 ) fwL->motor_drive = -127;
		FwLMotorSet( fwL->motor_drive );
		wait1Msec( FWL_LOOP_SPEED );
	}
}

task
FwRControlTask()
{
	fwR_controller *fwR = &flywheelR;
	fwR->gain = 0.00015;
	fwR->ticks_per_rev = MOTOR_TPR_393S;
	while(1)
	{
		fwR->counter++;
		FwRCalculateSpeed( fwR );
		fwR->current = fwR->v_current;
		FwRControlUpdateVelocityTbh( fwR ) ;
		fwR->motor_drive  = (fwR->drive * FWR_MAX_POWER) + 0.5;
		if( fwR->motor_drive >  127 ) fwR->motor_drive =  127;
		if( fwR->motor_drive < -127 ) fwR->motor_drive = -127;
		FwRMotorSet( fwR->motor_drive );
		wait1Msec( FWR_LOOP_SPEED );
	}
}

task main()
{
	char  str[32];
	bLCDBacklight = true;
	SensorValue[encoder_leftA] = 0;
	SensorValue[encoder_rightA] = 0;

	startTask( FwLControlTask );
	startTask( FwRControlTask );
	while(1)
	{
		if( vexRT[ Btn8L ] == 1 ){
			FwLVelocitySet( &flywheelL, 2260, 0.9 ); //2500 norm
			FwRVelocitySet( &flywheelR, 2260, 0.9 ); //2500 norm
		}else if( vexRT[ Btn8U ] == 1 ){
			FwLVelocitySet( &flywheelL, 1500, 0.5 );
			FwRVelocitySet( &flywheelR, 1500, 0.5 );
		}else if( vexRT[ Btn8R ] == 1 ){
			FwLVelocitySet( &flywheelL, 1100, 0.4 );
			FwRVelocitySet( &flywheelR, 1100, 0.4 );
		}else if( vexRT[ Btn8D ] == 1 ){
			FwLVelocitySet( &flywheelL, 00, 0);
			FwRVelocitySet( &flywheelR, 00, 0);
		}

		sprintf( str, "%4d %4d  %5.2f", flywheelL.target,  flywheelL.current, nImmediateBatteryLevel/1000.0 );
		displayLCDString(0, 0, str );
		sprintf( str, "%4d %4d", flywheelR.target,  flywheelR.current);
		displayLCDString(1, 0, str );

		wait1Msec(10);
	}

}
